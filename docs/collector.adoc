= Collector application
:toc: right

== Introduction

Include the library in your application as documented in the <<library#include,library>> documentation.

In order for a collector to work it needs to provide 2 resources:

. A <<_react_bundle, React bundle>> using semantic-ui-react-formik-functional.
. A <<_task,task>> that does the collecting.

In order for the main <<adin#,Explorer>> application to know where these resources is located a collector application needs to register itself:

== Register / unregister
.main.es
[source,java]
----
import {register} from '/lib/explorer/collector/register';
import {unregister} from '/lib/explorer/collector/unregister';

register({
	appName: app.name,
	collectTaskName: 'collect',
	configAssetPath: 'react/Collector.esm.js',
	displayName: 'My collector'
});

__.disposer(() => {
	unregister({
		appName: app.name
	});
});
----

== React bundle

Setting up a build system to provide the react bundle can be quite complex.

Thus we have made a starter-collector for you to use and learn from.

Some important ingredients are:

- node-gradle-plugin
- webpack
- babel
- node_modules
  * @enonic/webpack-esm-assets
  * @enonic/webpack-server-side-js

=== React component

In order for your collector's configuration user interface to work in Explorer you must provide a React component.
Any react component type should be supported, but all examples are functional (since that is the current status quo of react).

The component receives three props from Explorer:
. explorer - static information like contentTypes, fields and sites
. onChange - function you should call everytime you change values
. values - object to store your collectors configuration in


==== explorer object

This object contains information from Explorer about which contentTypes, fields and sites exists.
The information can be used to make dropdowns in your collectors configuration.

==== onChange function

Every time a form field value changes you should should write the change to the values object.
And every time the values object changes you should call the onChange function.

Here is one way to achieve this:

[source,javasript]
----
React.useEffect(() => {
	if (onChange) {
		onChange({
			dirty,
			isValid,
			values
		});
	}
}, [values]);
----

Notice the onChange function takes three named parameters.

. dirty - set this to true when the values object doesn't match the initially received values object.
. isValid - set this to false when form validation fails.
. values - your collector configuration object.

==== values object

This is where you store any configuration you want to use later in the collector task.

== Task

Developing a task to collect data can also be quite complex.

Have a look at the app-collector-simple to see an example.

Some important ingredients are:

- Progress
. Create/modify/delete
. Journal

The Enonic XP 7.x documentation on Tasks is still missing:
https://developer.enonic.com/docs/xp/stable/apps#tasks

So have a look at the Enonic XP 6.x documentation:
https://xp.readthedocs.io/en/stable/developer/tasks/index.html

.collect.es
[source,javascript]
----
import {Collector} from '/lib/explorer/collector'; <--1-->

export function run({name, configJson}) { <--2-->
	const collector = new Collector({name, configJson}); <--3-->

	if (!collector.config.uri) { <--4-->
		throw new Error('Config is missing required parameter uri!');
	}

	collector.start(); <--5-->

	const {
		uri,
		object: {
			someNestedProperty
		}
	} = collector.config; <--6-->

	while(somethingToDo) {
		if (collector.shouldStop()) { break; } <--7-->

		try {
			const {text, title} = doSomethingThatMayFail(); <--8-->

			collector.persistDocument({
				text,
				title,
				uri
			}); <--9-->

			collector.addSuccess({uri}); <--10-->

		} catch (e) {

			collector.addError({uri, message: e.message}); <--11-->

		}
	} // while somethingToDo

	// Perhaps delete documents that are no longer found...

	collector.stop(); <--12-->

} // export function run
----

<1> Import the Collector class
<2> The collect task gets passed two named parameters.
<3> Construct a Collector instance.
<4> Validate the configuration object.
<5> Start the collector. Sets startTime and more.
<6> Fetch configuration properties you need from the collector.config object.
<7> Check if someone has clicked the STOP button.
<8> This is where you collect the data you want to persist.
<9> Persist the collected data.
<10> Make a journal entry that collecting data from uri was a success.
<11> Make a journal entry that an error prevented collecting data from uri.
<12> Stop the collector. Sets endTime and more.
